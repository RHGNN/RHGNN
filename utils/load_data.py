import scipyimport numpy as npimport scipy.io as siofrom torch_geometric.data import Datadef getData(name, linktype, ispart=False):    path = '../data/' + name + '/'    dataname = name + 'dataset'    data = sio.loadmat(path + dataname + '.mat')    truelabels = data['label']    truefeatures = data['feature']    rownetworks = data[linktype][0]    if ispart:        knownindex = data['knownindex'][0]    else:        knownindex = None    return truelabels, truefeatures, rownetworks, knownindexdef sparse_to_tuple(matrix):    if not scipy.sparse.isspmatrix_coo(matrix):        matrix = matrix.tocoo()        coords = np.vstack((matrix.row, matrix.col)).transpose()        values = matrix.data        shape = matrix.shape        return coords, values, shapedef process(name):    para = {'dataset': name,            'algorithm': 'ourlayer', 'output_type': 'softmax', 'linktype': 'links',  ##describe the experiment            'stack_layer': 5, 'ishighway': True, 'isshared': True,  ##stack            '_kernel_size': 2, '_inception_depth': 4, 'hiddennum': 16,  ##convolution paramater            'dropout': 0.5, 'ispart': False  ##basic paramater            }    dataname = para['dataset']    if 'DBLP' in dataname:        para['output_type'] = 'softmax'        para['ispart'] = True    elif 'IMDB' in dataname:        para['output_type'] = 'sigmoid'    elif 'ACM' in dataname:        para['output_type'] = 'softmax'    elif 'SLAP' in dataname:        para['output_type'] = 'softmax'        para['ispart'] = True    truelabels, truefeatures, rownetworks, knownindex = getData(name, para['linktype'], para['ispart'])    path = '../data/' + name + '/'    np.save(path + 'knownindex', knownindex)def transfer_idx_to_mask(name):    path = '../data/' + name + '/'    num_nodes = 20419    train_idx = np.load(path + 'train_idx.npy')    val_idx = np.load(path + 'valid_idx.npy')    test_idx = np.load(path + 'test_idx.npy')    train_mask = np.zeros(num_nodes)    val_mask = np.zeros(num_nodes)    test_mask = np.zeros(num_nodes)    for i in range(len(train_idx)):        train_mask[train_idx[i]] = 1    for i in range(len(val_idx)):        val_mask[val_idx[i]] = 1    for i in range(len(test_idx)):        test_mask[test_idx[i]] = 1    np.save(path + 'train_mask.npy', train_mask)    np.save(path + 'valid_mask.npy', val_mask)    np.save(path + 'test_mask.npy', test_mask)def change_direction_to_undirection(name):    data = Data()    path = '../data/' + name + '/'    data.edge_index = np.load(path + 'edge_index.npy')    data.edge_type = np.load(path + 'edge_type.npy')    new_rows, new_columns = data.edge_index    new_v = data.edge_type    trans_rows = np.concatenate((new_rows, new_columns), axis=0)    trans_columns = np.concatenate((new_columns, new_rows), axis=0)    trans_v = np.concatenate((new_v, new_v), axis=0)    a = list(set([(r, c, v) for r, c, v in zip(trans_rows, trans_columns, trans_v)]))  # remove duplicate elements    a = np.array(a)    edge_index = a[:, :2].T    edge_type = np.squeeze(a[:, 2:])    sort_idx = np.argsort(edge_index[0])    edge_index[0] = edge_index[0][sort_idx]    edge_index[1] = edge_index[1][sort_idx]    edge_type = edge_type[sort_idx]    edge_type = np.array([x - 1 for x in edge_type])  # edge_type count from 0    np.save(path + 'edge_index.npy', edge_index)    np.save(path + 'edge_type.npy', edge_type)